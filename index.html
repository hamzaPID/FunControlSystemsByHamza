<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FunControlSystemsByHamza ‚Äì PID Playground</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
    }
    #container {
      display: flex;
      height: 100vh;
    }
    #controls {
      width: 280px;
      background: #ffffff;
      border-right: 1px solid #ddd;
      padding: 16px;
      box-sizing: border-box;
    }
    #controls h1 {
      font-size: 18px;
      margin: 0 0 6px;
    }
    #controls h2 {
      font-size: 14px;
      margin: 0 0 10px;
      color: #666;
    }
    #controls p {
      font-size: 13px;
      margin: 4px 0;
    }
    .scenario-box {
      margin-top: 6px;
      padding: 8px;
      border-radius: 6px;
      background: #f0f4ff;
      font-size: 13px;
    }
    button {
      padding: 6px 8px;
      margin: 5px 0;
      width: 100%;
      border-radius: 6px;
      border: 1px solid #888;
      background: #fafafa;
      cursor: pointer;
      font-size: 13px;
    }
    button:hover {
      background: #e8f0ff;
    }
    .scenario-btn.active {
      background: #2a7ae2;
      color: #fff;
      border-color: #2a7ae2;
    }
    .slider-group {
      margin-top: 8px;
    }
    .slider-group label {
      font-size: 13px;
      display: block;
      margin-bottom: 2px;
    }
    .slider-group input[type="range"] {
      width: 100%;
    }
    #visuals {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 12px;
      box-sizing: border-box;
      gap: 8px;
    }
    canvas {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    }
    #animCanvas {
      flex: 1;
    }
    #plotCanvas {
      flex: 1;
    }
    #infoText {
      font-size: 12px;
      color: #555;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="controls">
      <h1>FunControlSystemsByHamza</h1>
      <h2>PID Visual Playground</h2>

      <div class="scenario-box">
        <strong id="scenarioTitle">Drone altitude control</strong><br />
        <span id="scenarioDesc">
          The drone should reach and hold a target height of 1 m.
        </span>
      </div>

      <button id="btnDrone" class="scenario-btn active">üõ∏ Drone Altitude</button>
      <button id="btnServo" class="scenario-btn">‚öôÔ∏è Servo Position</button>
      <button id="btnLine" class="scenario-btn">ü§ñ Line-Follower Robot</button>

      <button id="playBtn" style="margin-top:8px;">‚ñ∂ Play / Re-run Animation</button>

      <div class="slider-group">
        <label for="kp">K<sub>p</sub> (Proportional): <span id="kpVal"></span></label>
        <input type="range" id="kp" min="0" max="60" step="1" value="18" />
      </div>
      <div class="slider-group">
        <label for="ki">K<sub>i</sub> (Integral): <span id="kiVal"></span></label>
        <input type="range" id="ki" min="0" max="20" step="0.5" value="5" />
      </div>
      <div class="slider-group">
        <label for="kd">K<sub>d</sub> (Derivative): <span id="kdVal"></span></label>
        <input type="range" id="kd" min="0" max="10" step="0.2" value="4" />
      </div>

      <p id="infoText">
        Increase K<sub>p</sub> ‚Üí faster but more overshoot.<br />
        Increase K<sub>i</sub> ‚Üí removes steady-state error.<br />
        Increase K<sub>d</sub> ‚Üí adds damping, reduces overshoot.
      </p>
    </div>

    <div id="visuals">
      <canvas id="animCanvas"></canvas>
      <canvas id="plotCanvas"></canvas>
    </div>
  </div>

  <script>
    // ================== Canvas setup ==================
    const animCanvas = document.getElementById("animCanvas");
    const plotCanvas = document.getElementById("plotCanvas");
    const animCtx = animCanvas.getContext("2d");
    const plotCtx = plotCanvas.getContext("2d");

    function resizeCanvases() {
      const visuals = document.getElementById("visuals");
      animCanvas.width = visuals.clientWidth - 16;
      animCanvas.height = Math.floor((visuals.clientHeight - 16) / 2);
      plotCanvas.width = visuals.clientWidth - 16;
      plotCanvas.height = Math.floor((visuals.clientHeight - 16) / 2);
    }
    window.addEventListener("resize", () => {
      resizeCanvases();
      if (currentSim) drawFrame(currentSim, currentIndex);
    });
    resizeCanvases();

    // ================== UI elements ==================
    const kpSlider = document.getElementById("kp");
    const kiSlider = document.getElementById("ki");
    const kdSlider = document.getElementById("kd");
    const kpVal = document.getElementById("kpVal");
    const kiVal = document.getElementById("kiVal");
    const kdVal = document.getElementById("kdVal");
    const playBtn = document.getElementById("playBtn");

    const btnDrone = document.getElementById("btnDrone");
    const btnServo = document.getElementById("btnServo");
    const btnLine  = document.getElementById("btnLine");

    const scenarioTitle = document.getElementById("scenarioTitle");
    const scenarioDesc  = document.getElementById("scenarioDesc");
    const infoText      = document.getElementById("infoText");

    // Scenario state
    let currentMode = "drone"; // 'drone' | 'servo' | 'line'

    const defaults = {
      drone: {Kp: 18, Ki: 5,  Kd: 4},
      servo: {Kp: 35, Ki: 8,  Kd: 1},
      line:  {Kp: 12, Ki: 3,  Kd: 2}
    };

    function updateScenarioText() {
      if (currentMode === "drone") {
        scenarioTitle.textContent = "Drone altitude control";
        scenarioDesc.textContent  = "Quadcopter moves up/down to reach 1 m altitude.";
        infoText.innerHTML =
          "Kp: reaction to height error.<br>" +
          "Ki: removes steady-state offset (too low/high).<br>" +
          "Kd: damps oscillations.";
      } else if (currentMode === "servo") {
        scenarioTitle.textContent = "Servo position control";
        scenarioDesc.textContent  = "Servo should rotate to 45¬∞ and hold that angle.";
        infoText.innerHTML =
          "Kp: how hard the servo turns towards the target.<br>" +
          "Ki: removes small angle error over time.<br>" +
          "Kd: smooths motion, reduces overshoot.";
      } else {
        scenarioTitle.textContent = "Line-following robot (lateral)";
        scenarioDesc.textContent  = "Robot should keep y = 0 (stay on the center line).";
        infoText.innerHTML =
          "Kp: how aggressively robot steers back to the line.<br>" +
          "Ki: removes constant bias (sensor misalignment).<br>" +
          "Kd: anticipates error change, reduces zig-zag.";
      }
    }

    function setDefaultsForMode(mode) {
      const d = defaults[mode];
      kpSlider.value = d.Kp;
      kiSlider.value = d.Ki;
      kdSlider.value = d.Kd;
      updateSliderLabels();
    }

    // ================== PID simulations ==================
    function simulateDrone(Kp, Ki, Kd) {
      const T = 8, dt = 0.02;
      const steps = Math.floor(T/dt) + 1;
      const t = new Array(steps);
      const y = new Array(steps);

      const m = 1.0, c = 1.2, k = 0.5;
      const r = 1.0;

      let z = 0, zdot = 0;
      let eInt = 0, ePrev = 0;

      for (let i = 0; i < steps; i++) {
        const ti = i * dt;
        t[i] = ti;
        const e = r - z;
        const de = (i === 0) ? 0 : (e - ePrev)/dt;
        eInt += e * dt;
        let u = Kp*e + Ki*eInt + Kd*de;
        if (u > 50) u = 50;
        if (u < -50) u = -50;

        const zddot = (u - c*zdot - k*z)/m;
        z += dt * zdot;
        zdot += dt * zddot;

        y[i] = z;
        ePrev = e;
      }
      return {t, y, r};
    }

    function simulateServo(Kp, Ki, Kd) {
      const T = 4, dt = 0.01;
      const steps = Math.floor(T/dt) + 1;
      const t = new Array(steps);
      const y = new Array(steps);

      const m = 0.02, c = 0.15, k = 0.5;
      const r = Math.PI/4;  // 45 deg

      let theta = 0, omega = 0;
      let eInt = 0, ePrev = 0;

      for (let i = 0; i < steps; i++) {
        const ti = i * dt;
        t[i] = ti;
        const e = r - theta;
        const de = (i === 0) ? 0 : (e - ePrev)/dt;
        eInt += e * dt;
        let u = Kp*e + Ki*eInt + Kd*de;
        if (u > 50) u = 50;
        if (u < -50) u = -50;

        const alpha = (u - c*omega - k*theta)/m;
        theta += dt * omega;
        omega += dt * alpha;

        y[i] = theta;
        ePrev = e;
      }
      return {t, y, r};
    }

    function simulateLineFollower(Kp, Ki, Kd) {
      const T = 8, dt = 0.02;
      const steps = Math.floor(T/dt) + 1;
      const t = new Array(steps);
      const y = new Array(steps);

      const m = 1.0, c = 1.0, k = 0.2;
      const r = 0.0;

      let pos = 0.3;   // lateral offset
      let vel = 0.0;
      let eInt = 0, ePrev = 0;

      for (let i = 0; i < steps; i++) {
        const ti = i * dt;
        t[i] = ti;
        const e = r - pos;
        const de = (i === 0) ? 0 : (e - ePrev)/dt;
        eInt += e * dt;
        let u = Kp*e + Ki*eInt + Kd*de;
        if (u > 50) u = 50;
        if (u < -50) u = -50;

        const acc = (u - c*vel - k*pos)/m;
        pos += dt * vel;
        vel += dt * acc;

        y[i] = pos;
        ePrev = e;
      }
      return {t, y, r};
    }

    // ================== Animation state ==================
    let currentSim = null;
    let currentIndex = 0;
    let animRequestId = null;

    function startAnimation(simData) {
      currentSim = simData;
      currentIndex = 0;
      if (animRequestId !== null) cancelAnimationFrame(animRequestId);
      animate();
    }

    function animate() {
      if (!currentSim) return;
      drawFrame(currentSim, currentIndex);
      currentIndex++;
      if (currentIndex < currentSim.t.length) {
        animRequestId = requestAnimationFrame(animate);
      }
    }

    // ================== Drawing for each mode ==================
    function drawFrame(simData, idx) {
      if (currentMode === "drone") {
        drawDroneFrame(simData, idx);
      } else if (currentMode === "servo") {
        drawServoFrame(simData, idx);
      } else {
        drawLineFrame(simData, idx);
      }
    }

    // ---- Drone ----
    function drawDroneFrame(simData, idx) {
      const {t, y, r} = simData;
      const n = t.length;
      const k = Math.min(idx, n-1);
      const yMin = Math.min(0, ...y);
      const yMax = Math.max(r*1.2, ...y, 0.1);

      const ctxA = animCtx;
      const W = animCanvas.width;
      const H = animCanvas.height;
      ctxA.clearRect(0, 0, W, H);

      const groundY = H*0.85;
      ctxA.strokeStyle = "#333";
      ctxA.lineWidth = 3;
      ctxA.beginPath();
      ctxA.moveTo(W*0.05, groundY);
      ctxA.lineTo(W*0.95, groundY);
      ctxA.stroke();
      ctxA.fillStyle = "#555";
      ctxA.font = "12px sans-serif";
      ctxA.fillText("Ground", W*0.06, groundY-6);

      const targetY = groundY - (r - yMin)/(yMax - yMin)*(H*0.6);
      ctxA.strokeStyle = "#999";
      ctxA.setLineDash([5,5]);
      ctxA.beginPath();
      ctxA.moveTo(W*0.15, targetY);
      ctxA.lineTo(W*0.85, targetY);
      ctxA.stroke();
      ctxA.setLineDash([]);
      ctxA.fillStyle = "#666";
      ctxA.fillText("Target altitude", W*0.16, targetY-6);

      const z = y[k];
      const droneY = groundY - (z - yMin)/(yMax - yMin)*(H*0.6);
      const droneX = W*0.5, droneW = 60, droneH = 25;

      ctxA.fillStyle = "#4da6ff";
      ctxA.strokeStyle = "#222";
      ctxA.lineWidth = 2;
      ctxA.beginPath();
      ctxA.roundRect(droneX-droneW/2, droneY-droneH/2, droneW, droneH, 6);
      ctxA.fill(); ctxA.stroke();

      ctxA.lineWidth = 3;
      ctxA.beginPath();
      ctxA.moveTo(droneX-droneW/2, droneY-droneH/2);
      ctxA.lineTo(droneX-droneW/2-10, droneY-droneH/2-12);
      ctxA.moveTo(droneX+droneW/2, droneY-droneH/2);
      ctxA.lineTo(droneX+droneW/2+10, droneY-droneH/2-12);
      ctxA.stroke();

      ctxA.fillStyle = "#000";
      ctxA.font = "12px sans-serif";
      ctxA.fillText(`t = ${t[k].toFixed(2)} s`, W*0.72, H*0.16);

      drawTimePlot({t, y, r, yMin, yMax, label:"Altitude (m)"}, k);
    }

    // ---- Servo ----
    function drawServoFrame(simData, idx) {
      const {t, y, r} = simData;
      const n = t.length;
      const k = Math.min(idx, n-1);
      const theta = y[k];

      const yMin = Math.min(0, ...y, r-0.1);
      const yMax = Math.max(r*1.2, ...y, 0.1);

      const ctxA = animCtx;
      const W = animCanvas.width;
      const H = animCanvas.height;
      ctxA.clearRect(0, 0, W, H);

      const cx = W*0.5, cy = H*0.55, R = Math.min(W,H)*0.25;
      ctxA.strokeStyle = "#333";
      ctxA.lineWidth = 2;
      ctxA.beginPath();
      ctxA.arc(cx, cy, R, 0, 2*Math.PI);
      ctxA.stroke();
      ctxA.fillStyle = "#000";
      ctxA.font = "14px sans-serif";
      ctxA.fillText("Servo", cx-20, cy-R-10);

      // Reference pointer
      ctxA.strokeStyle = "#999";
      ctxA.lineWidth = 2;
      ctxA.beginPath();
      ctxA.moveTo(cx, cy);
      ctxA.lineTo(cx + R*Math.cos(r), cy - R*Math.sin(r));
      ctxA.stroke();
      ctxA.fillStyle = "#666";
      ctxA.font = "12px sans-serif";
      ctxA.fillText("Target angle", cx+R*0.4, cy-R*0.4);

      // Actual pointer
      ctxA.strokeStyle = "#2a7ae2";
      ctxA.lineWidth = 4;
      ctxA.beginPath();
      ctxA.moveTo(cx, cy);
      ctxA.lineTo(cx + R*Math.cos(theta), cy - R*Math.sin(theta));
      ctxA.stroke();

      ctxA.fillStyle = "#000";
      ctxA.font = "12px sans-serif";
      ctxA.fillText(`Œ∏ = ${(theta*180/Math.PI).toFixed(1)}¬∞`, cx-35, cy+R+16);
      ctxA.fillText(`t = ${t[k].toFixed(2)} s`, cx+R*0.5, cy+R+16);

      drawTimePlot({t, y, r, yMin, yMax, label:"Angle (rad)"}, k);
    }

    // ---- Line follower ----
    function drawLineFrame(simData, idx) {
      const {t, y, r} = simData;
      const n = t.length;
      const k = Math.min(idx, n-1);

      const yMin = Math.min(...y, -0.5);
      const yMax = Math.max(...y, 0.5);

      const ctxA = animCtx;
      const W = animCanvas.width;
      const H = animCanvas.height;
      ctxA.clearRect(0, 0, W, H);

      const lineY = H*0.5;
      ctxA.strokeStyle = "#000";
      ctxA.lineWidth = 3;
      ctxA.beginPath();
      ctxA.moveTo(W*0.1, lineY);
      ctxA.lineTo(W*0.9, lineY);
      ctxA.stroke();
      ctxA.fillStyle = "#555";
      ctxA.font = "12px sans-serif";
      ctxA.fillText("Ideal path (y = 0)", W*0.12, lineY-8);

      const xProgress = W*0.1 + (W*0.8)*(k/(n-1));
      const yVal = y[k];
      const yVis = lineY - (yVal - 0)/(0.5)*(H*0.3); // scale

      const radius = 15;
      ctxA.fillStyle = "#3aaa35";
      ctxA.strokeStyle = "#222";
      ctxA.lineWidth = 2;
      ctxA.beginPath();
      ctxA.arc(xProgress, yVis, radius, 0, 2*Math.PI);
      ctxA.fill();
      ctxA.stroke();

      ctxA.fillStyle = "#000";
      ctxA.font = "12px sans-serif";
      ctxA.fillText(`y = ${yVal.toFixed(2)} m`, xProgress-30, yVis-radius-8);
      ctxA.fillText(`t = ${t[k].toFixed(2)} s`, W*0.72, H*0.18);

      drawTimePlot({t, y, r, yMin, yMax, label:"Lateral position y (m)"}, k);
    }

    // ---- Generic time plot ----
    function drawTimePlot(cfg, k) {
      const {t, y, r, yMin, yMax, label} = cfg;
      const n = t.length;

      const ctxP = plotCtx;
      const Wp = plotCanvas.width;
      const Hp = plotCanvas.height;
      ctxP.clearRect(0, 0, Wp, Hp);

      ctxP.strokeStyle = "#444";
      ctxP.lineWidth = 1;
      ctxP.beginPath();
      ctxP.moveTo(40, 10);
      ctxP.lineTo(40, Hp-30);
      ctxP.lineTo(Wp-10, Hp-30);
      ctxP.stroke();

      ctxP.fillStyle = "#000";
      ctxP.font = "12px sans-serif";
      ctxP.fillText(label, 6, 16);
      ctxP.fillText("Time (s)", Wp-60, Hp-10);

      // Reference
      ctxP.strokeStyle = "#999";
      ctxP.setLineDash([4,4]);
      ctxP.beginPath();
      for (let i=0; i<n; i++) {
        const x = 40 + (t[i]/t[n-1])*(Wp-60);
        const yPlot = (Hp-30) - (r - yMin)/(yMax - yMin)*(Hp-60);
        if (i===0) ctxP.moveTo(x,yPlot); else ctxP.lineTo(x,yPlot);
      }
      ctxP.stroke();
      ctxP.setLineDash([]);

      // Output
      ctxP.strokeStyle = "#2a7ae2";
      ctxP.lineWidth = 2;
      ctxP.beginPath();
      for (let i=0; i<=k; i++) {
        const x = 40 + (t[i]/t[n-1])*(Wp-60);
        const yPlot = (Hp-30) - (y[i] - yMin)/(yMax - yMin)*(Hp-60);
        if (i===0) ctxP.moveTo(x,yPlot); else ctxP.lineTo(x,yPlot);
      }
      ctxP.stroke();

      ctxP.fillStyle = "#000";
      ctxP.font = "11px sans-serif";
      ctxP.fillText("Reference", 52, 20);
      ctxP.fillText("Output", 52, 34);
      ctxP.strokeStyle = "#999";
      ctxP.beginPath();
      ctxP.moveTo(120,16); ctxP.lineTo(150,16); ctxP.stroke();
      ctxP.strokeStyle = "#2a7ae2";
      ctxP.beginPath();
      ctxP.moveTo(120,30); ctxP.lineTo(150,30); ctxP.stroke();
    }

    // ================== UI wiring ==================
    function updateSliderLabels() {
      kpVal.textContent = parseFloat(kpSlider.value).toFixed(1);
      kiVal.textContent = parseFloat(kiSlider.value).toFixed(1);
      kdVal.textContent = parseFloat(kdSlider.value).toFixed(1);
    }
    kpSlider.addEventListener("input", updateSliderLabels);
    kiSlider.addEventListener("input", updateSliderLabels);
    kdSlider.addEventListener("input", updateSliderLabels);

    playBtn.addEventListener("click", () => {
      const Kp = parseFloat(kpSlider.value);
      const Ki = parseFloat(kiSlider.value);
      const Kd = parseFloat(kdSlider.value);
      let sim;
      if (currentMode === "drone") sim = simulateDrone(Kp,Ki,Kd);
      else if (currentMode === "servo") sim = simulateServo(Kp,Ki,Kd);
      else sim = simulateLineFollower(Kp,Ki,Kd);
      startAnimation(sim);
    });

    function setActiveButton() {
      [btnDrone, btnServo, btnLine].forEach(b => b.classList.remove("active"));
      if (currentMode === "drone") btnDrone.classList.add("active");
      else if (currentMode === "servo") btnServo.classList.add("active");
      else btnLine.classList.add("active");
    }

    btnDrone.addEventListener("click", () => {
      currentMode = "drone";
      setActiveButton();
      setDefaultsForMode("drone");
      updateScenarioText();
      const sim = simulateDrone(
        parseFloat(kpSlider.value),
        parseFloat(kiSlider.value),
        parseFloat(kdSlider.value)
      );
      startAnimation(sim);
    });

    btnServo.addEventListener("click", () => {
      currentMode = "servo";
      setActiveButton();
      setDefaultsForMode("servo");
      updateScenarioText();
      const sim = simulateServo(
        parseFloat(kpSlider.value),
        parseFloat(kiSlider.value),
        parseFloat(kdSlider.value)
      );
      startAnimation(sim);
    });

    btnLine.addEventListener("click", () => {
      currentMode = "line";
      setActiveButton();
      setDefaultsForMode("line");
      updateScenarioText();
      const sim = simulateLineFollower(
        parseFloat(kpSlider.value),
        parseFloat(kiSlider.value),
        parseFloat(kdSlider.value)
      );
      startAnimation(sim);
    });

    // Initialize
    updateSliderLabels();
    updateScenarioText();
    const initialSim = simulateDrone(
      parseFloat(kpSlider.value),
      parseFloat(kiSlider.value),
      parseFloat(kdSlider.value)
    );
    startAnimation(initialSim);
  </script>
</body>
</html>
